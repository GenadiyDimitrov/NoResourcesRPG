@page "/game"
@implements IAsyncDisposable

@using NoResourcesRPG.Client.Services
@using NoResourcesRPG.Shared
@using NoResourcesRPG.Shared.DTOs;
@using NoResourcesRPG.Shared.Enums
@using NoResourcesRPG.Shared.Models
@using NoResourcesRPG.Shared.Static


@inject GameService GameService
@inject CanvasService CanvasService


<style>
    .wrapper {
        display: flex;
        flex-direction: row;
        flex-grow: 1;
        gap: 10px;
    }

    #gameCanvas {
        flex-grow: 1;
        border: solid black 1px;
    }
</style>

<div class="wrapper">
    @if (map.Player != null)
    {
        <div class="inventory">
            <ul>
                @foreach (var group in map.Player.Inventory.Values)
                {
                    @foreach (var item in group.Values)
                    {
                        <li style="color:@item.Color">@($"{item.Name} - {item.Amount}")</li>
                    }
                }
            </ul>
        </div>
    }
    <canvas id="gameCanvas"
            tabindex="0" @onkeydown="HandleKey"
            @onclick="OnCanvasClick"></canvas>
</div>
@code {
    private int recSize = GlobalConst.TileSize;
    private MapUpdateDto map = new();
    private const string canvasId = "gameCanvas";
    private bool _dirty;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await CanvasService.StartRenderLoop(this);
            GameService.OnPlayerDisconnected += (id) =>
            {
                if (map.Players.Remove(id))
                    _dirty = true;
            };

            GameService.OnMapUpdate += (update) =>
            {
                map = update;
                _dirty = true;
            };
            await GameService.Init();

        }
    }
    [JSInvokable]
    public void RenderFrame()
    {
        _ = Draw();
    }
    private async Task Draw()
    {
        if (!_dirty || map.Player is null) return;
        _dirty = false;
        await CanvasService.DrawWorldAsync(canvasId, map, recSize);
    }

    private async Task HandleKey(KeyboardEventArgs e)
    {
        if (map.Player != null)
        {
            var self = map.Player;
            int dx = 0, dy = 0;
            string action = null;

            // Movement keys
            switch (e.Key)
            {
                case "ArrowUp": dy = -1; break;
                case "ArrowDown": dy = 1; break;
                case "ArrowLeft": dx = -1; break;
                case "ArrowRight": dx = 1; break;
                case " ": // spacebar gather

                    var px = self.X * recSize + recSize / 2;
                    var py = self.Y * recSize + recSize / 2;
                    await Gather(px, py);
                    return;
            }

            // System / action keys
            switch (e.Key)
            {
                case "Control":        // Ctrl
                    action = "Special";
                    break;
                case "Alt":            // Alt
                    action = "AltAction";
                    break;
                case "Shift":          // Shift
                    action = "Run";
                    break;
            }


            // Movement
            if (dx != 0 || dy != 0)
            {
                await GameService.Move(new PlayerActionDto
                {
                    PlayerId = self.Id,
                    Action = "Move",
                    X = dx,
                    Y = dy
                });
            }

            // Action (space/ctrl/alt/shift)
            if (!string.IsNullOrEmpty(action))
            {
                await GameService.Action(new PlayerActionDto
                {
                    PlayerId = self.Id,
                    Action = action,
                    X = 0,
                    Y = 0
                });
            }
        }
    }
    private async Task OnCanvasClick(MouseEventArgs e)
    {
        var clickX = e.OffsetX;
        var clickY = e.OffsetY;
        await Gather(clickX, clickY);
    }
    private async Task Gather(double x, double y)
    {
        if (map.Player is null || !map.Resources.Any())
            return;

        var self = map.Player;
        var res = map.Resources
                     .FirstOrDefault(r =>
                     x >= r.X * recSize &&
                     x <= r.X * recSize + recSize &&
                     y >= r.Y * recSize &&
                     y <= r.Y * recSize + recSize);

        if (res is null) return;

        Console.WriteLine($"{res.Type} Gathared");
        // Check if player is next to the resource
        int dx = Math.Abs(self.X - res.X);
        int dy = Math.Abs(self.Y - res.Y);

        if (dx <= 1 && dy <= 1) // player can be adjacent or on the tile
        {
            await GameService.Collect(new PlayerActionDto
            {
                PlayerId = self.Id,
                Action = "Gather",
                X = res.X,
                Y = res.Y
            });
        }
    }
    public async ValueTask DisposeAsync()
    {
        Console.WriteLine("Disposing Game.razor");
        await CanvasService.DisposeAsync();
    }
}

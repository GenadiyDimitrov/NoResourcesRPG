@page "/game"
@implements IAsyncDisposable

@using NoResourcesRPG.Client.Helpers
@using NoResourcesRPG.Client.Services
@using NoResourcesRPG.Shared
@using NoResourcesRPG.Shared.DTOs;
@using NoResourcesRPG.Shared.Enums
@using NoResourcesRPG.Shared.Models
@using NoResourcesRPG.Shared.Static


@inject GameService GameService
@inject CanvasService CanvasService


<style>
    .wrapper {
        display: flex;
        flex-direction: row;
        flex-grow: 1;
        gap: 10px;
    }

    #gameCanvas {
        flex-grow: 1;
        border: solid black 1px;
    }
</style>

<div class="wrapper">
    @if (map.Player != null)
    {
        <div class="inventory">
            <ul>
                @foreach (var group in map.Player.Inventory.Values)
                {
                    @foreach (var item in group.Values)
                    {
                        <li style="color:@item.Color">@($"{item.Name} - {item.Amount}")</li>
                    }
                }
            </ul>
        </div>
    }
    <canvas id="gameCanvas"
            tabindex="0"
            @onkeydown="HandleKey"
            @onpointerdown="(e) => _pointerEventHelper.OnPointerDown(e, CanvasService, canvasId)"
            @onpointerup="(e) => _pointerEventHelper.OnPointerUp(e, CanvasService, canvasId)"
            @onpointermove="(e) => _pointerEventHelper.OnPointerMove(e, CanvasService, canvasId)"></canvas>
</div>
@code {
    private const string canvasId = "gameCanvas";

    private PointerEventHelper _pointerEventHelper = new();
    private int recSize = GlobalConst.TileSize;
    private MapUpdateDto map = new();
    private bool _dirty;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            _pointerEventHelper.OnClick += OnGather;
            _pointerEventHelper.OnDrag += Move;
            await CanvasService.StartRenderLoop(this);
            GameService.OnPlayerDisconnected += (id) =>
            {
                if (map.Players.Remove(id))
                    _dirty = true;
            };

            GameService.OnMapUpdate += (update) =>
            {
                map = update;
                _dirty = true;
            };
            await GameService.Init();

        }
    }
    [JSInvokable]
    public void RenderFrame()
    {
        _ = Draw();
    }
    private async Task Draw()
    {
        if (!_dirty || map.Player is null) return;
        _dirty = false;
        await CanvasService.DrawWorldAsync(canvasId, map, recSize);
    }
    private async void Move(double dx, double dy)
    {
        if (map.Player != null)
        {
            var self = map.Player;
            int dxInt = 0, dyInt = 0;
            if (dx > 0) dxInt = 1;
            else if (dx < 0) dxInt = -1;
            if (dy > 0) dyInt = 1;
            else if (dy < 0) dyInt = -1;
            await Move(self, dxInt, dyInt);
        }
    }
    private async Task Move(Character self, int dx, int dy)
    {
        await GameService.Move(new PlayerActionDto
        {
            PlayerId = self.Id,
            Action = "Move",
            X = dx,
            Y = dy
        });
    }
    private async Task HandleKey(KeyboardEventArgs e)
    {
        if (map.Player != null)
        {
            var self = map.Player;
            int dx = 0, dy = 0;
            string action = null;

            // Movement keys
            switch (e.Key)
            {
                case "ArrowUp": dy = -1; break;
                case "ArrowDown": dy = 1; break;
                case "ArrowLeft": dx = -1; break;
                case "ArrowRight": dx = 1; break;
                case " ": // spacebar gather

                    var px = self.X * recSize + recSize / 2;
                    var py = self.Y * recSize + recSize / 2;
                    await Gather(px, py);
                    return;
            }

            // System / action keys
            switch (e.Key)
            {
                case "Control":        // Ctrl
                    action = "Special";
                    break;
                case "Alt":            // Alt
                    action = "AltAction";
                    break;
                case "Shift":          // Shift
                    action = "Run";
                    break;
            }


            // Movement
            if (dx != 0 || dy != 0)
            {
                await Move(self, dx, dy);
            }

            // Action (space/ctrl/alt/shift)
            if (!string.IsNullOrEmpty(action))
            {
                await GameService.Action(new PlayerActionDto
                {
                    PlayerId = self.Id,
                    Action = action,
                    X = 0,
                    Y = 0
                });
            }
        }
    }
    public async void OnGather(Size size)
    {
        if (map.Player is null || !map.Resources.Any())
            return;
        var self = map.Player;

        var px = self.X * recSize + recSize / 2;
        var py = self.Y * recSize + recSize / 2;
        double worldX = px + (size.Left - (size.Width / 2 - recSize / 2));
        double worldY = py + (size.Top - (size.Height / 2 - recSize / 2));
        await Gather(worldX, worldY);
    }
    public async Task Gather(double x, double y)
    {
        Console.WriteLine($"Try Gathar {x}x{y}");
        if (map.Player is null || !map.Resources.Any())
            return;

        var self = map.Player;
        var res = map.Resources
                     .FirstOrDefault(r =>
                     x >= r.X * recSize &&
                     x <= r.X * recSize + recSize &&
                     y >= r.Y * recSize &&
                     y <= r.Y * recSize + recSize);

        if (res is null) return;

        Console.WriteLine($"{res.Type} Gathared");
        // Check if player is next to the resource
        int dx = Math.Abs(self.X - res.X);
        int dy = Math.Abs(self.Y - res.Y);

        if (dx <= 1 && dy <= 1) // player can be adjacent or on the tile
        {
            await GameService.Collect(new PlayerActionDto
            {
                PlayerId = self.Id,
                Action = "Gather",
                X = res.X,
                Y = res.Y
            });
        }
    }
    public async ValueTask DisposeAsync()
    {
        Console.WriteLine("Disposing Game.razor");
        await CanvasService.DisposeAsync();
    }
}
